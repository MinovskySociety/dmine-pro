
#优化基于遍历整个搜索空间的dmine运行时间的相关措施 

目前dmine运行效率低下的几个主要问题：
1.搜索空间太大，对整个搜索空间的pattern进行匹配需要很大的时间
2.存在一小部分pattern匹配时间过长
3.存在很多语义上没意义的pattern


|优化|目的|问题1优化效果|问题2优化效果|问题3优化效果|整体运行效果|
|:--|:--|:--|:--|:--|:--|
|拓展pattern的过程中，将所有父pattern的supp取交|减少匹配次数，过滤掉那些没有match的点|无|有|无|减少运行时间|
|匹配过程中，动态调整节点的Candidate Set|减少匹配次数，确定更优的Match Order|无|有|无|减少运行时间|
|采用boost iso的思想对Data Graph进行缩点|减少Data Graph的规模|无|有|无|减少运行时间|
|将supp整体传入匹配中，而不是枚举supp查看是否有匹配|某些情况下可以确定更优的Match Order，减少计算时间|无|部分Pattern优化较好，部分Pattern效果更差|无|运行时间增加|
|增强了InitCandidateSet的检测条件（增加CountInVertex,CountOutVertex)|减少C(u)的大小|无|对于部分匹配为0的Pattern效果显著，但是每个Pattern增加了一部分运算时间|无|增加运行时间|
|利用之前匹配的先验知识进行剪枝|减少需要匹配的Pattern个数|有|无|无|运行时间先减少再增加|
|人为规定Pattern具有的特性|符合相关需求的语义|有|无|未知|运行时间减少|



#实验数据
## boost iso缩点结果
对于目前的DataGraph进行boost_iso中提到的SEC关系缩点之后，新图的点数为3227，约为原来的42% 边数为109886，为原来的96.67%
其中，用户点均未被缩点
## dmine运行时间
|d|运行时间|采用boost iso之后的运行时间|进入下一轮的Pattern数|
|:--|:--|:--|:--|
|1||||
|2|1.17308s|0.92s|27|
|3|8.49855s|6.79138s|143|
|4|111.153s|103.26s|822|
|5|6150.13s|5012.25s|5112|

##采用“利用之前匹配的先验知识进行剪枝”的dmine运行时间
思路：维护一个Pattern的List L，在匹配的过程中，首先
检查Pattern的子图是否与L中某个pattern同构，若同构则不
进行匹配，不同构则继续进行匹配，若该次匹配结果为0，
则将该Pattern加入到L中。

|L.size()|d=4运行时间|d=5运行时间|
|:--|:--|:--|
|0|103.26s|5012.25s|
|5|55.1976s|2702.62s|
|10|53.8974s|1652.59s|
|15|52.4975s|1393.34s|
|17|50.2231s|1928.5s|
|20|50.38s|1433.51s|


##采用“利用之前匹配的先验知识进行剪枝”的dmine运行时间

### 限制Pattern的User节点个数为1
|d|运行时间|进入下一轮的Pattern数|
|:--|:--|:--|
|4|13.8066s|296|
|5|51.1452s|933|
|6|180.248s|2773|
|7|759.046s|7804|

### 限制Pattern的User节点个数小于等于2
|d|运行时间|进入下一轮的Pattern数|
|:--|:--|:--|
|4|42.2645s |740|
|5|438.082s|3772|
|6|超过2h，未跑完|未知|
|7|未知|未知|